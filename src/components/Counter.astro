---
// Counter.astro - Real-time counter component displaying elapsed time since October 8, 2023
import { calculateElapsedTime, formatTimeUnit } from '../utils/timeCalculations';
import { START_TIMESTAMP, COUNTER_UPDATE_INTERVAL } from '../utils/constants';
import type { TimeElapsed } from '../types';

// Server-side calculation for initial render
const currentTimestamp = Math.floor(Date.now() / 1000);
const initialElapsedTime = calculateElapsedTime(START_TIMESTAMP, currentTimestamp);
---

<div class="counter-container" role="main" aria-label="Palestine Solidarity Counter">
  <!-- Screen reader announcement for counter purpose -->
  <div class="sr-only" aria-live="polite" id="counter-description">
    Real-time counter showing elapsed time since October 8, 2023, when Israel declared war on Gaza
  </div>

  <!-- Loading state -->
  <div class="loading-overlay" id="loading-overlay" aria-hidden="true">
    <div class="loading-spinner" aria-label="Loading counter"></div>
    <span class="loading-text">Initializing counter...</span>
  </div>

  <!-- Error state -->
  <div class="error-boundary" id="error-boundary" aria-hidden="true" role="alert">
    <div class="error-content">
      <h3>Counter Error</h3>
      <p id="error-message">An error occurred while loading the counter.</p>
      <button type="button" id="retry-button" aria-label="Retry loading counter">
        Try Again
      </button>
    </div>
  </div>

  <!-- Main counter display -->
  <div class="counter-display" aria-describedby="counter-description" id="main-counter">
    <!-- Time units grid -->
    <div class="time-grid" role="timer" aria-live="polite" aria-atomic="true" aria-label="Elapsed time counter">
      <div class="time-unit" data-unit="years">
        <span class="time-value" id="years-value">{initialElapsedTime.years}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.years} years`}>
          {initialElapsedTime.years === 1 ? 'Year' : 'Years'}
        </span>
      </div>

      <div class="time-unit" data-unit="months">
        <span class="time-value" id="months-value">{initialElapsedTime.months}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.months} months`}>
          {initialElapsedTime.months === 1 ? 'Month' : 'Months'}
        </span>
      </div>

      <div class="time-unit" data-unit="days">
        <span class="time-value" id="days-value">{initialElapsedTime.days}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.days} days`}>
          {initialElapsedTime.days === 1 ? 'Day' : 'Days'}
        </span>
      </div>

      <div class="time-unit" data-unit="hours">
        <span class="time-value" id="hours-value">{initialElapsedTime.hours}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.hours} hours`}>
          {initialElapsedTime.hours === 1 ? 'Hour' : 'Hours'}
        </span>
      </div>

      <div class="time-unit" data-unit="minutes">
        <span class="time-value" id="minutes-value">{initialElapsedTime.minutes}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.minutes} minutes`}>
          {initialElapsedTime.minutes === 1 ? 'Minute' : 'Minutes'}
        </span>
      </div>

      <div class="time-unit" data-unit="seconds">
        <span class="time-value" id="seconds-value">{initialElapsedTime.seconds}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.seconds} seconds`}>
          {initialElapsedTime.seconds === 1 ? 'Second' : 'Seconds'}
        </span>
      </div>
    </div>

    <!-- Alternative format for screen readers -->
    <div class="sr-only" aria-live="polite" id="counter-alt-format">
      Total elapsed time: {initialElapsedTime.totalDays} days, {initialElapsedTime.totalHours} hours
    </div>
  </div>
</div>

<style>
  .counter-container {
    width: 100%;
    max-width: 72rem;
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  .counter-display {
    text-align: center;
  }

  .time-grid {
    display: grid;
    gap: 1rem;
    /* Responsive grid layout */
    grid-template-columns: repeat(2, 1fr); /* Mobile: 2 columns */
  }

  @media (min-width: 640px) {
    .time-grid {
      gap: 1.5rem;
      grid-template-columns: repeat(3, 1fr); /* Tablet: 3 columns */
    }
  }

  @media (min-width: 1024px) {
    .time-grid {
      gap: 2rem;
      grid-template-columns: repeat(6, 1fr); /* Desktop: 6 columns */
    }
  }

  .time-unit {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    background-color: white;
    border: 2px solid #e5e7eb;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    transition: all 0.3s ease-in-out;
    min-height: 120px;
  }

  @media (min-width: 768px) {
    .time-unit {
      padding: 1.5rem;
    }
  }

  .time-unit:hover {
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    border-color: #fca5a5;
  }

  .time-value {
    font-size: 1.875rem;
    font-weight: 700;
    color: var(--color-palestine-red);
    line-height: 1;
    margin-bottom: 0.5rem;
    font-variant-numeric: tabular-nums;
    font-feature-settings: 'tnum' 1;
  }

  @media (min-width: 768px) {
    .time-value {
      font-size: 2.25rem;
    }
  }

  @media (min-width: 1024px) {
    .time-value {
      font-size: 3rem;
    }
  }

  .time-label {
    font-size: 0.875rem;
    color: var(--color-gray-700);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    line-height: 1.25;
  }

  @media (min-width: 768px) {
    .time-label {
      font-size: 1rem;
    }
  }

  @media (min-width: 1024px) {
    .time-label {
      font-size: 1.125rem;
    }
  }

  /* Screen reader only content */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Focus styles for accessibility */
  .time-unit:focus-within {
    outline: none;
    box-shadow: 0 0 0 2px var(--color-palestine-red), 0 0 0 4px rgba(206, 17, 38, 0.2);
  }

  /* Animation for value changes */
  .time-value {
    transition: color 0.2s ease-in-out;
  }

  .time-value.updating {
    color: var(--color-palestine-green);
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .time-unit {
      border: 4px solid black;
    }
    
    .time-value {
      color: black;
    }
    
    .time-label {
      color: black;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .time-unit,
    .time-value {
      transition: none;
    }
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .time-unit {
      background-color: #1f2937;
      border-color: #4b5563;
    }
    
    .time-label {
      color: #d1d5db;
    }
  }

  /* Loading overlay */
  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.9);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    transition: opacity 0.3s ease-in-out;
  }

  .loading-overlay[aria-hidden="true"] {
    opacity: 0;
    pointer-events: none;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f4f6;
    border-top: 4px solid var(--color-palestine-red);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
  }

  .loading-text {
    color: var(--color-gray-700);
    font-weight: 500;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Error boundary */
  .error-boundary {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(248, 113, 113, 0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 20;
    transition: opacity 0.3s ease-in-out;
  }

  .error-boundary[aria-hidden="true"] {
    opacity: 0;
    pointer-events: none;
  }

  .error-content {
    background-color: white;
    padding: 2rem;
    border-radius: 0.5rem;
    box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
    text-align: center;
    max-width: 400px;
    margin: 0 1rem;
  }

  .error-content h3 {
    color: var(--color-palestine-red);
    font-size: 1.5rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
  }

  .error-content p {
    color: var(--color-gray-700);
    margin-bottom: 1.5rem;
  }

  #retry-button {
    background-color: var(--color-palestine-red);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 0.375rem;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s ease-in-out;
  }

  #retry-button:hover {
    background-color: #dc2626;
  }

  #retry-button:focus {
    outline: none;
    box-shadow: 0 0 0 2px var(--color-palestine-red), 0 0 0 4px rgba(206, 17, 38, 0.2);
  }

  /* Loading and error states in dark mode */
  @media (prefers-color-scheme: dark) {
    .loading-overlay {
      background-color: rgba(31, 41, 55, 0.9);
    }
    
    .loading-text {
      color: #d1d5db;
    }
    
    .error-content {
      background-color: #1f2937;
    }
    
    .error-content p {
      color: #d1d5db;
    }
  }
</style>

<script>
  // Client-side TypeScript for real-time updates
  import { calculateElapsedTime } from '../utils/timeCalculations';
  import { START_TIMESTAMP, COUNTER_UPDATE_INTERVAL } from '../utils/constants';
  import type { TimeElapsed } from '../types';

  class CounterManager {
    private intervalId: number | null = null;
    private isActive: boolean = false;
    private lastUpdateTime: number = 0;
    private rafId: number | null = null;
    private isVisible: boolean = true;
    private errorCount: number = 0;
    private maxRetries: number = 3;
    private elements: {
      years: HTMLElement | null;
      months: HTMLElement | null;
      days: HTMLElement | null;
      hours: HTMLElement | null;
      minutes: HTMLElement | null;
      seconds: HTMLElement | null;
      altFormat: HTMLElement | null;
      loadingOverlay: HTMLElement | null;
      errorBoundary: HTMLElement | null;
      errorMessage: HTMLElement | null;
      retryButton: HTMLElement | null;
      mainCounter: HTMLElement | null;
    };

    constructor() {
      this.elements = {
        years: document.getElementById('years-value'),
        months: document.getElementById('months-value'),
        days: document.getElementById('days-value'),
        hours: document.getElementById('hours-value'),
        minutes: document.getElementById('minutes-value'),
        seconds: document.getElementById('seconds-value'),
        altFormat: document.getElementById('counter-alt-format'),
        loadingOverlay: document.getElementById('loading-overlay'),
        errorBoundary: document.getElementById('error-boundary'),
        errorMessage: document.getElementById('error-message'),
        retryButton: document.getElementById('retry-button'),
        mainCounter: document.getElementById('main-counter')
      };

      this.init();
    }

    private init(): void {
      // Show loading state
      this.showLoading();

      // Set up retry button handler
      if (this.elements.retryButton) {
        this.elements.retryButton.addEventListener('click', () => {
          this.retry();
        });
      }

      // Simulate initialization delay and then start
      setTimeout(() => {
        try {
          this.hideLoading();
          this.start();
        } catch (error) {
          this.handleError(error as Error);
        }
      }, 100);

      // Handle page visibility changes to pause/resume counter
      document.addEventListener('visibilitychange', () => {
        this.isVisible = !document.hidden;
        if (document.hidden) {
          this.pause();
        } else {
          this.resume();
        }
      });

      // Handle focus/blur for additional performance optimization
      window.addEventListener('focus', () => {
        if (this.isVisible) this.resume();
      });

      window.addEventListener('blur', () => {
        this.pause();
      });

      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        this.stop();
      });

      // Handle memory pressure events
      if ('memory' in performance) {
        window.addEventListener('beforeunload', () => {
          this.cleanup();
        });
      }
    }

    private updateDisplay(elapsedTime: TimeElapsed): void {
      // Update time values with animation
      this.updateTimeUnit('years', elapsedTime.years);
      this.updateTimeUnit('months', elapsedTime.months);
      this.updateTimeUnit('days', elapsedTime.days);
      this.updateTimeUnit('hours', elapsedTime.hours);
      this.updateTimeUnit('minutes', elapsedTime.minutes);
      this.updateTimeUnit('seconds', elapsedTime.seconds);

      // Update alternative format for screen readers
      if (this.elements.altFormat) {
        this.elements.altFormat.textContent = 
          `Total elapsed time: ${elapsedTime.totalDays} days, ${elapsedTime.totalHours} hours`;
      }

      // Update aria-labels for better accessibility
      this.updateAriaLabels(elapsedTime);
    }

    private updateTimeUnit(unit: keyof typeof this.elements, value: number): void {
      const element = this.elements[unit];
      if (!element) return;

      const currentValue = parseInt(element.textContent || '0');
      
      if (currentValue !== value) {
        // Add updating class for animation
        element.classList.add('updating');
        
        // Update the value
        element.textContent = value.toString();
        
        // Remove animation class after a short delay
        setTimeout(() => {
          element.classList.remove('updating');
        }, 200);
      }
    }

    private updateAriaLabels(elapsedTime: TimeElapsed): void {
      const units = ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] as const;
      
      units.forEach(unit => {
        const element = this.elements[unit];
        if (element) {
          const value = elapsedTime[unit];
          const label = element.nextElementSibling as HTMLElement;
          if (label) {
            label.setAttribute('aria-label', `${value} ${unit}`);
          }
        }
      });
    }

    private calculateCurrentElapsedTime(): TimeElapsed {
      const currentTimestamp = Math.floor(Date.now() / 1000);
      return calculateElapsedTime(START_TIMESTAMP, currentTimestamp);
    }

    private tick(): void {
      try {
        const now = Date.now();
        
        // Throttle updates to avoid excessive re-renders
        if (now - this.lastUpdateTime < COUNTER_UPDATE_INTERVAL - 50) {
          return;
        }
        
        this.lastUpdateTime = now;
        const elapsedTime = this.calculateCurrentElapsedTime();
        
        // Use requestAnimationFrame for smooth updates
        if (this.rafId) {
          cancelAnimationFrame(this.rafId);
        }
        
        this.rafId = requestAnimationFrame(() => {
          this.updateDisplay(elapsedTime);
          this.rafId = null;
        });
        
        // Reset error count on successful update
        this.errorCount = 0;
      } catch (error) {
        this.handleError(error as Error);
      }
    }

    private showLoading(): void {
      if (this.elements.loadingOverlay) {
        this.elements.loadingOverlay.setAttribute('aria-hidden', 'false');
      }
      if (this.elements.mainCounter) {
        this.elements.mainCounter.style.opacity = '0.3';
      }
    }

    private hideLoading(): void {
      if (this.elements.loadingOverlay) {
        this.elements.loadingOverlay.setAttribute('aria-hidden', 'true');
      }
      if (this.elements.mainCounter) {
        this.elements.mainCounter.style.opacity = '1';
      }
    }

    private showError(message: string): void {
      if (this.elements.errorBoundary) {
        this.elements.errorBoundary.setAttribute('aria-hidden', 'false');
      }
      if (this.elements.errorMessage) {
        this.elements.errorMessage.textContent = message;
      }
      if (this.elements.mainCounter) {
        this.elements.mainCounter.style.opacity = '0.3';
      }
    }

    private hideError(): void {
      if (this.elements.errorBoundary) {
        this.elements.errorBoundary.setAttribute('aria-hidden', 'true');
      }
      if (this.elements.mainCounter) {
        this.elements.mainCounter.style.opacity = '1';
      }
    }

    private handleError(error: Error): void {
      console.error('Counter error:', error);
      this.errorCount++;
      
      if (this.errorCount >= this.maxRetries) {
        this.showError(`Failed to update counter after ${this.maxRetries} attempts. ${error.message}`);
        this.stop();
      } else {
        // Try to continue running for temporary errors
        console.warn(`Counter error ${this.errorCount}/${this.maxRetries}, continuing...`);
      }
    }

    private retry(): void {
      this.hideError();
      this.errorCount = 0;
      this.showLoading();
      
      setTimeout(() => {
        try {
          this.hideLoading();
          this.start();
        } catch (error) {
          this.handleError(error as Error);
        }
      }, 500);
    }

    public start(): void {
      if (this.isActive) return;

      this.isActive = true;
      
      // Update immediately
      this.tick();
      
      // Set up interval for regular updates
      this.intervalId = window.setInterval(() => {
        this.tick();
      }, COUNTER_UPDATE_INTERVAL);
    }

    public pause(): void {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      this.isActive = false;
    }

    public resume(): void {
      if (!this.isActive) {
        this.start();
      }
    }

    public stop(): void {
      this.pause();
      this.cleanup();
    }

    private cleanup(): void {
      // Cancel any pending animation frames
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
      
      // Clear interval
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      
      // Remove event listeners to prevent memory leaks
      window.removeEventListener('focus', this.resume);
      window.removeEventListener('blur', this.pause);
      
      this.isActive = false;
    }
  }

  // Initialize counter when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new CounterManager();
    });
  } else {
    new CounterManager();
  }
</script>