---
// Counter.astro - Real-time counter component displaying elapsed time since October 8, 2023
import { calculateElapsedTime, formatTimeUnit } from '../utils/timeCalculations';
import { START_TIMESTAMP, COUNTER_UPDATE_INTERVAL } from '../utils/constants';
import type { TimeElapsed } from '../types';

// Server-side calculation for initial render
const currentTimestamp = Math.floor(Date.now() / 1000);
const initialElapsedTime = calculateElapsedTime(START_TIMESTAMP, currentTimestamp);
---

<div class="counter-container" role="main" aria-label="Palestine Solidarity Counter">
  <!-- Screen reader announcement for counter purpose -->
  <div class="sr-only" aria-live="polite" id="counter-description">
    Real-time counter showing elapsed time since October 8, 2023, when Israel declared war on Gaza
  </div>

  <!-- Main counter display -->
  <div class="counter-display" aria-describedby="counter-description">
    <!-- Time units grid -->
    <div class="time-grid" role="timer" aria-live="polite" aria-atomic="true" aria-label="Elapsed time counter">
      <div class="time-unit" data-unit="years">
        <span class="time-value" id="years-value">{initialElapsedTime.years}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.years} years`}>
          {initialElapsedTime.years === 1 ? 'Year' : 'Years'}
        </span>
      </div>

      <div class="time-unit" data-unit="months">
        <span class="time-value" id="months-value">{initialElapsedTime.months}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.months} months`}>
          {initialElapsedTime.months === 1 ? 'Month' : 'Months'}
        </span>
      </div>

      <div class="time-unit" data-unit="days">
        <span class="time-value" id="days-value">{initialElapsedTime.days}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.days} days`}>
          {initialElapsedTime.days === 1 ? 'Day' : 'Days'}
        </span>
      </div>

      <div class="time-unit" data-unit="hours">
        <span class="time-value" id="hours-value">{initialElapsedTime.hours}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.hours} hours`}>
          {initialElapsedTime.hours === 1 ? 'Hour' : 'Hours'}
        </span>
      </div>

      <div class="time-unit" data-unit="minutes">
        <span class="time-value" id="minutes-value">{initialElapsedTime.minutes}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.minutes} minutes`}>
          {initialElapsedTime.minutes === 1 ? 'Minute' : 'Minutes'}
        </span>
      </div>

      <div class="time-unit" data-unit="seconds">
        <span class="time-value" id="seconds-value">{initialElapsedTime.seconds}</span>
        <span class="time-label" aria-label={`${initialElapsedTime.seconds} seconds`}>
          {initialElapsedTime.seconds === 1 ? 'Second' : 'Seconds'}
        </span>
      </div>
    </div>

    <!-- Alternative format for screen readers -->
    <div class="sr-only" aria-live="polite" id="counter-alt-format">
      Total elapsed time: {initialElapsedTime.totalDays} days, {initialElapsedTime.totalHours} hours
    </div>
  </div>
</div>

<style>
  .counter-container {
    width: 100%;
    max-width: 72rem;
    margin: 0 auto;
    padding: 2rem 1rem;
  }

  .counter-display {
    text-align: center;
  }

  .time-grid {
    display: grid;
    gap: 1rem;
    /* Responsive grid layout */
    grid-template-columns: repeat(2, 1fr); /* Mobile: 2 columns */
  }

  @media (min-width: 640px) {
    .time-grid {
      gap: 1.5rem;
      grid-template-columns: repeat(3, 1fr); /* Tablet: 3 columns */
    }
  }

  @media (min-width: 1024px) {
    .time-grid {
      gap: 2rem;
      grid-template-columns: repeat(6, 1fr); /* Desktop: 6 columns */
    }
  }

  .time-unit {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    background-color: white;
    border: 2px solid #e5e7eb;
    border-radius: 0.5rem;
    box-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    transition: all 0.3s ease-in-out;
    min-height: 120px;
  }

  @media (min-width: 768px) {
    .time-unit {
      padding: 1.5rem;
    }
  }

  .time-unit:hover {
    box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    border-color: #fca5a5;
  }

  .time-value {
    font-size: 1.875rem;
    font-weight: 700;
    color: var(--color-palestine-red);
    line-height: 1;
    margin-bottom: 0.5rem;
    font-variant-numeric: tabular-nums;
    font-feature-settings: 'tnum' 1;
  }

  @media (min-width: 768px) {
    .time-value {
      font-size: 2.25rem;
    }
  }

  @media (min-width: 1024px) {
    .time-value {
      font-size: 3rem;
    }
  }

  .time-label {
    font-size: 0.875rem;
    color: var(--color-gray-700);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    line-height: 1.25;
  }

  @media (min-width: 768px) {
    .time-label {
      font-size: 1rem;
    }
  }

  @media (min-width: 1024px) {
    .time-label {
      font-size: 1.125rem;
    }
  }

  /* Screen reader only content */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Focus styles for accessibility */
  .time-unit:focus-within {
    outline: none;
    box-shadow: 0 0 0 2px var(--color-palestine-red), 0 0 0 4px rgba(206, 17, 38, 0.2);
  }

  /* Animation for value changes */
  .time-value {
    transition: color 0.2s ease-in-out;
  }

  .time-value.updating {
    color: var(--color-palestine-green);
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .time-unit {
      border: 4px solid black;
    }
    
    .time-value {
      color: black;
    }
    
    .time-label {
      color: black;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .time-unit,
    .time-value {
      transition: none;
    }
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .time-unit {
      background-color: #1f2937;
      border-color: #4b5563;
    }
    
    .time-label {
      color: #d1d5db;
    }
  }
</style>

<script>
  // Client-side TypeScript for real-time updates
  import { calculateElapsedTime } from '../utils/timeCalculations';
  import { START_TIMESTAMP, COUNTER_UPDATE_INTERVAL } from '../utils/constants';
  import type { TimeElapsed } from '../types';

  class CounterManager {
    private intervalId: number | null = null;
    private isActive: boolean = false;
    private elements: {
      years: HTMLElement | null;
      months: HTMLElement | null;
      days: HTMLElement | null;
      hours: HTMLElement | null;
      minutes: HTMLElement | null;
      seconds: HTMLElement | null;
      altFormat: HTMLElement | null;
    };

    constructor() {
      this.elements = {
        years: document.getElementById('years-value'),
        months: document.getElementById('months-value'),
        days: document.getElementById('days-value'),
        hours: document.getElementById('hours-value'),
        minutes: document.getElementById('minutes-value'),
        seconds: document.getElementById('seconds-value'),
        altFormat: document.getElementById('counter-alt-format')
      };

      this.init();
    }

    private init(): void {
      // Start the counter when the page loads
      this.start();

      // Handle page visibility changes to pause/resume counter
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          this.pause();
        } else {
          this.resume();
        }
      });

      // Clean up on page unload
      window.addEventListener('beforeunload', () => {
        this.stop();
      });
    }

    private updateDisplay(elapsedTime: TimeElapsed): void {
      // Update time values with animation
      this.updateTimeUnit('years', elapsedTime.years);
      this.updateTimeUnit('months', elapsedTime.months);
      this.updateTimeUnit('days', elapsedTime.days);
      this.updateTimeUnit('hours', elapsedTime.hours);
      this.updateTimeUnit('minutes', elapsedTime.minutes);
      this.updateTimeUnit('seconds', elapsedTime.seconds);

      // Update alternative format for screen readers
      if (this.elements.altFormat) {
        this.elements.altFormat.textContent = 
          `Total elapsed time: ${elapsedTime.totalDays} days, ${elapsedTime.totalHours} hours`;
      }

      // Update aria-labels for better accessibility
      this.updateAriaLabels(elapsedTime);
    }

    private updateTimeUnit(unit: keyof typeof this.elements, value: number): void {
      const element = this.elements[unit];
      if (!element) return;

      const currentValue = parseInt(element.textContent || '0');
      
      if (currentValue !== value) {
        // Add updating class for animation
        element.classList.add('updating');
        
        // Update the value
        element.textContent = value.toString();
        
        // Remove animation class after a short delay
        setTimeout(() => {
          element.classList.remove('updating');
        }, 200);
      }
    }

    private updateAriaLabels(elapsedTime: TimeElapsed): void {
      const units = ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] as const;
      
      units.forEach(unit => {
        const element = this.elements[unit];
        if (element) {
          const value = elapsedTime[unit];
          const label = element.nextElementSibling as HTMLElement;
          if (label) {
            label.setAttribute('aria-label', `${value} ${unit}`);
          }
        }
      });
    }

    private calculateCurrentElapsedTime(): TimeElapsed {
      const currentTimestamp = Math.floor(Date.now() / 1000);
      return calculateElapsedTime(START_TIMESTAMP, currentTimestamp);
    }

    private tick(): void {
      try {
        const elapsedTime = this.calculateCurrentElapsedTime();
        this.updateDisplay(elapsedTime);
      } catch (error) {
        console.error('Counter update error:', error);
        // Continue running even if there's an error
      }
    }

    public start(): void {
      if (this.isActive) return;

      this.isActive = true;
      
      // Update immediately
      this.tick();
      
      // Set up interval for regular updates
      this.intervalId = window.setInterval(() => {
        this.tick();
      }, COUNTER_UPDATE_INTERVAL);
    }

    public pause(): void {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      this.isActive = false;
    }

    public resume(): void {
      if (!this.isActive) {
        this.start();
      }
    }

    public stop(): void {
      this.pause();
    }
  }

  // Initialize counter when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new CounterManager();
    });
  } else {
    new CounterManager();
  }
</script>